***9. —ËÒÚÂÏ‡ RSA***

def multipliers(n):
    x = isqrt(n) + 1
    y = isqrt(x**2 - n)
    p = x - y
    q = x + y

    if p * q == n:
        print('P=',p)
        print('Q=',q)

def dec_to_string(ds):
    # œÂÂ‚Ó‰ËÚ¸ ‰ÂÒˇÚÍÓ‚Â ˜ËÒÎÓ Û ÚÂÍÒÚÓ‚ËÈ ˇ‰ÓÍ
    bs = bin(ds)[2:]
    bs = bs.zfill(len(bs)+(8-(len(bs)%8)))
    s = ''
    for i in range(0,len(bs),8):
        s += chr(int(bs[i:i+8],2))
    return s

C = 1369617520343736604681509545987401107472610213155449180224072143018640110640406921298600588205501186

n = 2155521117027243630973823963847695675142648931978141801990016117470096232504563101608940380959903957

e = 65537

p,q = multipliers(n)

phi = (p-1)*(q-1)

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

d = modinv(e, phi)

print(dec_to_string(pow(C,d,n)))
